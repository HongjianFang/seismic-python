#! /usr/bin/env python
from seispy.locate import Locator
from seispy.util import MultiThreadProcess
from gazelle.datascope import Database
import argparse
import ConfigParser


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("db", type=str, nargs=1)
    parser.add_argument("config", type=str, nargs=1)
    parser.add_argument("-s", "--subset", type=str)
    return parser.parse_args()


def parse_config(args):
    cfg = {}
    config = ConfigParser.RawConfigParser()
    config.read(args.config[0])
    cfg["tt_dir"] = config.get("General", "tt_dir")
    cfg["mode"] = config.get("General", "mode")
    cfg["author"] = config.get("General", "author")
    cfg["n_threads"] = config.getint("General", "n_threads")
    cfg["min_nsta"] = config.getint("General", "min_nsta")
    cfg["P_residual_tolerance"] = config.getfloat("General",
                                                  "P_residual_tolerance")
    cfg["S_residual_tolerance"] = config.getfloat("General",
                                                  "S_residual_tolerance")
    cfg["convergance_threshold"] = config.getfloat("General",
                                                   "convergance_threshold")
    cfg["max_iterations"] = config.getint("General", "max_iterations")
    cfg["input_q_size"] = config.getint("General", "input_q_size")
    cfg["output_q_size"] = config.getint("General", "output_q_size")
    return cfg


def getter(args):
    print "INITIALIZE REAP THREAD"
    for origin in args.db.iterate_events(subset=args.subset,
                                         parse_magnitudes=False):
        yield origin

def _main_processor(origin, cfg):
    locator = Locator(cfg)
    if cfg['mode'] == 'relocate':
        return locator.relocate(origin)
    elif cfg['mode'] == 'locate':
        new = locator.locate(origin)
        if new is None:
            import seispy.burrow
            import matplotlib.pyplot as plt
            from obspy.core import Stream
            import os
            willy = seispy.burrow.Groundhog()
            st = Stream()
            picks = []
            try:
                os.mkdir(str(origin.evid))
            except OSError:
                pass
            for arrival in sorted(origin.arrivals,
                                  key = lambda arrival: (arrival.station.network,
                                                         arrival.station.name,
                                                         arrival.channel)):
                st += willy.fetch(arrival.station.name,
                                  arrival.channel.code,
                                  origin.time,
                                  origin.time + 20)
                pick = arrival.time.toordinal() +\
                    arrival.time._get_hours_after_midnight() / 24.
                if arrival.phase == "P":
                    color = "r"
                else:
                    color = "b"
                picks += [(pick, color)]
            st.filter("highpass", freq=3.0)
            st.trim(starttime=origin.time + 2)
            st.normalize()
            st = [st[i * 10:(i + 1) * 10] for i in range(len(st) / 10)]
            picks = [picks[i * 10:(i + 1) * 10] for i in range(len(picks) / 10)]
            arrivals = [origin.arrivals[i * 10:(i + 1) * 10] for i in range(len(origin.arrivals) / 10)]
            for i in range(len(st)):
                fig = st[i].plot(handle=True,
                                 equal_scale=True)
                for j in range(len(fig.axes)):
                    arrival = arrivals[i][j]
                    fig.axes[j].axvline(picks[i][j][0],
                                        color=picks[i][j][1])
                plt.savefig("%d/traces_%d.png" % (origin.evid, i), format="png")
            origin.plot(save="%d/map.png" % origin.evid,
                        show=False)
            #plt.show()
    else:
        print "invalid mode: %s" % cfg['mode']
        exit()

def main_processor(origin, cfg):
    locator = Locator(cfg)
    if cfg['mode'] == 'relocate':
        return locator.relocate(origin)
    elif cfg['mode'] == 'locate':
        return locator.locate(origin)
    else:
        print "invalid mode: %s" % cfg['mode']
        exit()


def outputter(origin, args, cfg):
    if origin is None:
        return
    if cfg['mode'] == 'relocate':
        auth = cfg['author'] + ":reloc"
    elif cfg['mode'] == 'locate':
        auth = cfg['author'] + ":loc"
    origin.author = auth
    args.db.write_origin(origin)


def main():
    args.db = Database(args.db[0], mode='r+')
    config_params = {'n_threads': cfg['n_threads'],
                     'input_q_max_size': cfg['input_q_size'],
                     'output_q_max_size': cfg['output_q_size']}
    extra_args = {'input_init_args': (args,),
                  'main_init_args': (cfg,),
                  'output_init_args': (args, cfg)}
    mtp = MultiThreadProcess(getter,
                             main_processor,
                             outputter,
                             extra_args=extra_args,
                             config_params=config_params)
    mtp.start()
    args.db.close()

if __name__ == "__main__":
    args = parse_args()
    cfg = parse_config(args)
    main()
